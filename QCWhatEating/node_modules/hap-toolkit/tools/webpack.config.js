/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */

const path = require('path')
const fs = require('fs')
const yargs = require('yargs')
const fsExtra = require('fs-extra')

const webpack = require('webpack')

const { colorconsole } = require('./packager/common/utils')
const info = require('./packager/common/info')
// 暂时暴露全局
global.colorconsole = colorconsole

// 开发者传递的参数
const options = Object.assign({}, yargs.argv)

// 支持文件扩展名
const FILE_EXT_LIST = info.name.extList

// 文件类型
const UX_TYPE = {
  APP: 'app',
  PAGE: 'page'
}
// 项目目录
const pathProject = process.cwd()
// 源代码目录
const pathSrc = path.join(pathProject, 'src')
// 输出目标目录
const nameBuild = 'build'
// 构建目录
const pathBuild = path.join(pathProject, nameBuild)
// 最终发布目录
const pathDist = path.join(pathProject, 'dist')
// 打包配置文件
const nameManifest = 'manifest.json'
const pathManifest = path.join(pathSrc, nameManifest)
// 工具目录
const pathDirname = __dirname

// 校验项目工程
!validateProject()

// manifest.json对象
const manifestObj = getManifest(pathManifest)

// 应用与页面的脚本文件
const scriptFileList = extractScriptFiles()

// 页面文件
const zipPages = {}

// 提取脚本文件，资源文件
extractSourceFiles('.', false, scriptFileList)

// 配置环境
const nodeConf = parseEnv()

const webpackConf = {
  entry: zipPages,
  output: {
    path: pathBuild,
    filename: '[name]'
  },
  module: {
    rules: []
  },
  plugins: [
    // 定义环境变量
    new webpack.DefinePlugin({
      // 平台：na
      ENV_PLATFORM: JSON.stringify(nodeConf.NODE_PLATFORM),
      // 阶段: dv|qa|ol
      ENV_PHASE: JSON.stringify(nodeConf.NODE_PHASE),
      ENV_PHASE_DV: nodeConf.NODE_PHASE === 'dv',
      ENV_PHASE_QA: nodeConf.NODE_PHASE === 'qa',
      ENV_PHASE_OL: nodeConf.NODE_PHASE === 'ol'
    }),
    // 编译耗时
    function () {
      this.plugin('run', function (compiler, callback) {
        process.webpackDateS = new Date()
        callback()
      })
      this.plugin('watch-run', function (compiler, callback) {
        process.webpackDateS = new Date()
        callback()
      })
      this.plugin('done', function () {
        process.webpackDateE = new Date()
        const secCost = (process.webpackDateE - process.webpackDateS) / 1000
        colorconsole.info(`Build Time Cost: ${secCost}s`)
      })
    }
  ],
  node: {
    global: false
  },
  resolve: {
    modules: [
      'node_modules',
      // 测试用例在test目录下
      path.join(pathProject, 'test')
    ],
    extensions: ['.webpack.js', '.web.js', '.js', '.json'].concat(FILE_EXT_LIST)
  },
  stats: {
    children: false,
    chunks: false,
    chunkModules: false,
    chunkOrigins: false,
    modules: false,
    version: false,
    assets: false
  }
}

// 环境配置
if (nodeConf.NODE_PHASE === 'dv') {
  // 开发：sourcemap
  if (!options.envDisableSourceMap) {
    webpackConf.devtool = 'source-map'
  }
}
else {
  // 正式：压缩去重
  webpackConf.plugins.push(new webpack.optimize.DedupePlugin())
  webpackConf.plugins.push(new webpack.optimize.UglifyJsPlugin())
}

// 加载配置
loadWebpackConfList()

module.exports = webpackConf

/**
 * 尝试加载每个模块的webpack配置
 */
function loadWebpackConfList () {
  const moduleList = findModuleList(pathDirname)

  // 增加：开发者项目目录下的config文件夹
  // 注意：Hook机制不保证向后兼容
  moduleList.push({ name: '', path: path.join(pathProject, 'config') })
  const { package: appPackageName, versionCode } = manifestObj
  for (let i = 0, len = moduleList.length; i < len; i++) {
    const moduleItem = moduleList[i]
    const fileConf = path.join(moduleItem.path, 'webpack.config.js')
    if (fs.existsSync(fileConf)) {
      try {
        const moduleWebpackConf = require(fileConf)
        if (moduleWebpackConf.postHook) {
          moduleWebpackConf.postHook(webpackConf, {
            appPackageName,
            versionCode,
            nodeConf,
            pathDist,
            pathDirname,
            pathSrc,
            pathBuild
          }, options)
        }
      }
      catch (err) {
        console.error(`加载webpack配置文件[${fileConf}]出错：${err.message}`)
      }
    }
  }
}

/**
 * 查找模块列表
 * @param parentDir
 * @return {Array}
 */
function findModuleList (parentDir) {
  const moduleList = []
  const fileNameList = fs.readdirSync(pathDirname)
  for (let i = 0, len = fileNameList.length; i < len; i++) {
    const fileName = fileNameList[i]
    const filePath = path.join(parentDir, fileName)
    const fileStat = fs.statSync(filePath)
    if (fileStat.isDirectory()) {
      moduleList.push({
        name: fileName,
        path: filePath
      })
    }
  }
  return moduleList
}

/**
 * 解析NODE环境的参数
 */
function parseEnv () {
  const config = {
    // 平台：na
    NODE_PLATFORM: process.env.NODE_PLATFORM,
    // 阶段: dv|qa|ol
    NODE_PHASE: process.env.NODE_PHASE,
    // 是否注入测试框架
    NODE_TEST: process.env.NODE_TEST
  }
  colorconsole.info(`配置环境：${JSON.stringify(config)}`)
  return config
}

/**
 * 验证项目配置正确
 */
function validateProject () {
  if (!fs.existsSync(pathManifest)) {
    colorconsole.throw(`请确认项目%projectDir%/src/下存在manifest.json文件：${pathManifest}`)
  }

  // 清空build目录
  fsExtra.emptyDirSync(pathBuild)
  // 清空dist路径
  if (fs.existsSync(pathDist)) {
    const zipfiles = fs.readdirSync(pathDist)
    zipfiles.forEach(function (file) {
      const curPath = pathDist + '/' + file
      if (fs.statSync(curPath).isFile()) {
        fs.unlinkSync(curPath)
      }
    })
  }
  return true
}

/**
 * 获取manifest文件
 * @param pathManifest
 */
function getManifest (pathManifest) {
  let config
  if (fs.existsSync(pathManifest)) {
    config = JSON.parse(fs.readFileSync(pathManifest))
  }
  return config || {}
}

/**
 * 提取其中的应用和页面脚本文件
 * @return {Array}
 */
function extractScriptFiles () {
  const files = []

  const appPath = info.findScriptFile(path.join(pathSrc, 'app'))
  if (!appPath) {
    colorconsole.throw(`app脚本文件丢失`)
  }
  files.push({ path: appPath, type: UX_TYPE.APP })

  const { router } = manifestObj
  if (manifestObj && router) {
    const pages = router.pages
    extractedItems(files, pages, UX_TYPE.PAGE)
  }
  return files
}

/**
 * 提取脚本文件
 * @param files
 * @param items
 * @param type
 */
function extractedItems (files, items, type = '') {
  if (items) {
    Object.keys(items).forEach(item => {
      const meta = items[item]
      // 如果忘记写组件, 则默认为页面的小写
      const compName = meta.component || item.toLowerCase()
      if (!meta || !meta.component) {
        colorconsole.warn(`manifest.json中的路由信息不全: 页面'${item}'没有设置component属性, 默认采用'${compName}'`)
      }
      const itemobj = {}
      itemobj.path = info.findScriptFile(path.join(pathSrc, item, compName))
      itemobj.type = type

      if (!itemobj.path) {
        colorconsole.throw(`manifest.json中路由[${item}]的文件路径[${itemobj.path}]不存在，请及时删除`)
      }
      else {
        files.push(itemobj)
      }
    })
  }
}

/**
 * 提取脚本文件，资源文件
 * @param dir
 * @param common
 */
function extractSourceFiles (dir, common, fileList) {
  dir = dir || '.'
  const directory = path.join(pathSrc, dir)
  let name
  // 递归遍历目录
  fs.readdirSync(directory)
    .forEach(function (file) {
      const fullpath = path.join(directory, file)
      const stat = fs.statSync(fullpath)
      const extname = path.extname(fullpath)
      if (stat.isFile()) {
        // 只处理指定类型的文件
        if ((FILE_EXT_LIST.indexOf(extname) >= 0) && !common) {
          // 是否在路由表中
          const findObj = fileList.find(item => { return item.path.indexOf(fullpath) > -1 })
          if (fileList.length === 0 || findObj) {
            name = path.join(nameBuild, dir, path.basename(file, extname)) + '.js'
            name = name.replace(/\\/g, '/')
            // 转换为在build目录下的地址
            const buildRelativeName = name.match(/build\/(.*)/)[1]
            zipPages[buildRelativeName] = fullpath + '?uxType=' + findObj.type
          }
        }
      }
      else if (stat.isDirectory()) {
        const subdir = path.join(dir, file)
        const iscommon = common || (file.toLowerCase() === 'common')
        extractSourceFiles(subdir, iscommon, fileList)
      }
    })
}
